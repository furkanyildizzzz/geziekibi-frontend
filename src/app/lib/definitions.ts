import { z } from "zod";

export const SignupFormSchema = z
  .object({
    firstName: z
      .string()
      .min(2, { message: "First name must be at least 2 characters long." }),
    lastName: z
      .string()
      .min(2, { message: "Last name must be at least 2 characters long." }),
    email: z.string().email({ message: "Please enter a valid email" }).trim(),
    password: z
      .string()
      // .min(8, { message: "Be at least 8 characters long." })
      .regex(/[a-zA-Z]/, { message: "Contain at least one letter." })
      // .regex(/[0-9]/, { message: "Contain at least one number." })
      // .regex(/[^a-zA-Z0-9]/, {
      //   message: "Contain at least one special character.",
      // })
      .trim(),
    passwordConfirm: z.string().trim(),
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: "Passwords don't match",
    path: ["passwordConfirm"],
  });
export type SignupSchema = z.infer<typeof SignupFormSchema>;

export const SigninFormSchema = z.object({
  email: z.string().email({ message: "Please enter a valid email" }).trim(),
  password: z.string({ message: "Please enter a valid password" }).trim(),
});
export type SigninSchema = z.infer<typeof SigninFormSchema>;

export const CreateTagFormSchema = z.object({
  name: z
    .string({ message: "Please enter valid tag name" })
    .min(3, { message: "Be at least 3 charactes long" })
    .trim(),
});
export type CreateTagSchema = z.infer<typeof CreateTagFormSchema>;

export const CreateTourCategoryFormSchema = z.object({
  name: z
    .string({ message: "Please enter valid category name" })
    .min(3, { message: "Be at least 3 charactes long" })
    .trim(),
  description: z.string().optional(),
  parentid: z.number().optional(),
});
export type CreateTourCategorySchema = z.infer<
  typeof CreateTourCategoryFormSchema
>;

export const CreateServiceFormSchema = z.object({
  name: z
    .string({ message: "Please enter valid category name" })
    .min(3, { message: "Be at least 3 charactes long" })
    .trim(),
  description: z.string().optional(),
});
export type CreateServiceSchema = z.infer<typeof CreateServiceFormSchema>;

const fileSizeLimit = 5 * 1024 * 1024; // 5MB

// Image Schema
export const SINGLE_IMAGE_SCHEMA = z
  .instanceof(File)
  .refine(
    (file) =>
      [
        "image/png",
        "image/jpeg",
        "image/jpg",
        "image/svg+xml",
        "image/gif",
      ].includes(file.type),
    { message: "Invalid image file type" }
  )
  .refine((file) => file.size <= fileSizeLimit, {
    message: "File size should not exceed 5MB",
  });
export type SINGLEIMAGESCHEMA = z.infer<typeof SINGLE_IMAGE_SCHEMA>;

// Document Schema
export const DOCUMENT_SCHEMA = z
  .instanceof(File)
  .refine(
    (file) =>
      [
        "application/pdf",
        "application/vnd.ms-excel",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      ].includes(file.type),
    { message: "Invalid document file type" }
  )
  .refine((file) => file.size <= fileSizeLimit, {
    message: "File size should not exceed 5MB",
  });
export type DOCUMENTSCHEMA = z.infer<typeof DOCUMENT_SCHEMA>;

export const MULTIPLE_IMAGE_SCHEMA = z
  .unknown()
  .transform((value) => {
    return value as FileList;
  })
  .refine((list) => list.length > 0, "No files selected")
  .refine((list) => list.length <= 5, "Maximum 5 files allowed")
  .transform((list) => Array.from(list))
  .refine(
    (files) => {
      const allowedTypes: { [key: string]: boolean } = {
        "image/jpeg": true,
        "image/png": true,
        "application/pdf": true,
        "application/msword": true,
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
          true,
      };
      return files.every((file) => allowedTypes[file.type]);
    },
    { message: "Invalid file type. Allowed types: JPG, PNG, PDF, DOC, DOCX" }
  )
  .refine(
    (files) => {
      return files.every((file) => file.size <= fileSizeLimit);
    },
    {
      message: "File size should not exceed 5MB",
    }
  );
export type MULTIPLEIMAGESCHEMA = z.infer<typeof MULTIPLE_IMAGE_SCHEMA>;

export const TourValidationSchema = z.object({
  id: z.number().optional(), // Primary key, autogenerated
  title: z.string().min(1, { message: "Title is required" }),
  spot: z.string().min(1, { message: "Spot is required" }),
  body: z.string().optional(), // 'text' type is generally optional in validation
  publishStatus: z
    .nativeEnum({
      PUBLISH: "publish",
      DRAFT: "draft",
      UNPUBLISH: "unpublish",
    })
    .default("draft"),
  type: z
    .nativeEnum({
      YURTDISI: "yurtdisi",
      YURTICI: "yurtici",
      GUNUBIRLIK: "gunubirlik",
    })
    .default("yurtdisi"),
  publishDate: z
    .date({
      message: "Invalid date format",
    })
    .optional(),
  image: z.any().optional(), // Allow any file object for image
  gallery: z.array(z.any()).optional(), // Allow an array of any file objects for gallery
  created_at: z.date().optional(), // Timestamps, typically set automatically
  updated_at: z.date().optional(),
  tags: z.array(z.object({ id: z.number() })).optional(), // Assuming `tags` are referenced by `id`
  prices: z
    .array(
      z.object({
        price: z
          .number()
          .positive({ message: "Price amount must be positive" }),
        currency: z.string().min(1, { message: "Currency is required" }),
      })
    )
    .optional(),
  categoryId: z.number({ message: "Category is required" }), // Category is referenced by `id`
  tourServices: z
    .array(
      z.object({
        id: z.number(),
        name: z.string().min(1, { message: "Service name is required" }),
      })
    )
    .optional(),
});
